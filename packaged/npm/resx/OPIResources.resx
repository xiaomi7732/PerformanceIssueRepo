<?xml version="1.0" encoding="utf-8"?>
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="$schema" xml:space="preserve">
    <value>2.0</value>
  </data>
  <data name="032a1d51428a4b16bf75ebff5e1755d2_Title" xml:space="preserve">
    <value>Inefficient String Concatenation</value>
  </data>
  <data name="032a1d51428a4b16bf75ebff5e1755d2_Description" xml:space="preserve">
    <value>Excessive string concatenation is causing lots of allocations and CPU consumption.</value>
  </data>
  <data name="032a1d51428a4b16bf75ebff5e1755d2_DocURL" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2017/profiling/da0001-use-stringbuilder-for-concatenations</value>
  </data>
  <data name="032a1d51428a4b16bf75ebff5e1755d2_Recommendation" xml:space="preserve">
    <value>Consider using StringBuilder to reduce concatenation operations.</value>
  </data>
  <data name="032a1d51428a4b16bf75ebff5e1755d2_Rationale" xml:space="preserve">
    <value />
  </data>
  <data name="3fa8074901a744efb90e712c67b417b4_Title" xml:space="preserve">
    <value>ThreadPool starvation events detected</value>
  </data>
  <data name="3fa8074901a744efb90e712c67b417b4_Description" xml:space="preserve">
    <value>ThreadPool starvation occurs when the pool has no available threads to process new work items and it often causes applications to respond slowly.</value>
  </data>
  <data name="3fa8074901a744efb90e712c67b417b4_DocURL" xml:space="preserve">
    <value>https://learn.microsoft.com/en-us/dotnet/core/diagnostics/debug-threadpool-starvation</value>
  </data>
  <data name="3fa8074901a744efb90e712c67b417b4_Recommendation" xml:space="preserve">
    <value>Follow the documentation to locate and fix the thread pool starvation issue.</value>
  </data>
  <data name="3fa8074901a744efb90e712c67b417b4_Rationale" xml:space="preserve">
    <value>{value} thread pool starvation events happened. We expect this number to be {relation} than {criteria}.</value>
  </data>
  <data name="daddcbb2da8f4b73936b7865c17699a5_Title" xml:space="preserve">
    <value>Excessive CPU time in OutputDebugStringW</value>
  </data>
  <data name="daddcbb2da8f4b73936b7865c17699a5_Description" xml:space="preserve">
    <value>Excessive CPU time is spent in OutputDebugStringW.</value>
  </data>
  <data name="daddcbb2da8f4b73936b7865c17699a5_Recommendation" xml:space="preserve">
    <value>Any CPU time spent in this API is likely a bug, as this API is only meant for use during debugging.  One way this shows up is via TraceInternal.Write* or TraceSource if System.Diagnostics.DefaultTraceListener is enabled.</value>
  </data>
  <assembly alias="System.Resources.NetStandard" name="System.Resources.NetStandard, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null" />
  <data name="daddcbb2da8f4b73936b7865c17699a5_Rationale" type="System.Resources.NetStandard.ResXNullRef, System.Resources.NetStandard">
    <value />
  </data>
  <data name="f7151cedf0734d65833aac8c01b6754f_Title" xml:space="preserve">
    <value>Inefficient Trace.WriteLine usage</value>
  </data>
  <data name="f7151cedf0734d65833aac8c01b6754f_Description" xml:space="preserve">
    <value>Excessive CPU time is spent in TraceInternal.WriteLine.</value>
  </data>
  <data name="f7151cedf0734d65833aac8c01b6754f_Recommendation" xml:space="preserve">
    <value>Consider reducing the amount of logging done in this app, or look at replacing this type of logging with a high-performance logger such as EventSource.</value>
  </data>
  <data name="f7151cedf0734d65833aac8c01b6754f_Rationale" xml:space="preserve">
    <value />
  </data>
  <data name="a9e711cbca1d4378b68992d1b03bc437_Title" xml:space="preserve">
    <value>Incorrect Equality Comparison Implementation</value>
  </data>
  <data name="a9e711cbca1d4378b68992d1b03bc437_Description" xml:space="preserve">
    <value>Reflection is being used by Compare/Equality functions. This could be because of a missing `Equals` override or incorrect `IEquatable&lt;T&gt;`/`IEqualityComparer&lt;T&gt;` implementation.</value>
  </data>
  <data name="a9e711cbca1d4378b68992d1b03bc437_Recommendation" xml:space="preserve">
    <value>This can be fixed by providing the missing `Equals` override or properly implementing the `IEquatable&lt;T&gt;`/`IEqualityComparer&lt;T&gt;` interface.</value>
  </data>
  <data name="a9e711cbca1d4378b68992d1b03bc437_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="68ff5cc5beaf4c2eb8f2433c48af1708_Title" xml:space="preserve">
    <value>Allocations in `Equals`/`GetHashCode`</value>
  </data>
  <data name="68ff5cc5beaf4c2eb8f2433c48af1708_Description" xml:space="preserve">
    <value>Hot-path methods like `Equals`/`GetHashCode` should be kept allocation free. LINQ methods tend to allocate enumerators on the Heap, while `string.Format` leads to string allocations.</value>
  </data>
  <data name="68ff5cc5beaf4c2eb8f2433c48af1708_Recommendation" xml:space="preserve">
    <value>This can be fixed by removing calls to such methods. LINQ queries can be unrolled into loops. `string.Format` can be replaced with a comparison of it's component strings.</value>
  </data>
  <data name="68ff5cc5beaf4c2eb8f2433c48af1708_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="9346bb84de0544cab2ff874eda19340e_Title" xml:space="preserve">
    <value>Excessive Allocations Due to List/Dictionary Resizing</value>
  </data>
  <data name="9346bb84de0544cab2ff874eda19340e_Description" xml:space="preserve">
    <value>Too many allocations are being caused by resizing due to calls associated with List/Dictionary resizing.</value>
  </data>
  <data name="9346bb84de0544cab2ff874eda19340e_Recommendation" xml:space="preserve">
    <value>Consider initializing the List/Dictionary with an explicit size if available or can be computed.</value>
  </data>
  <data name="9346bb84de0544cab2ff874eda19340e_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="9095c47b63d2447aac647d6740226546_Title" xml:space="preserve">
    <value>Excessive Allocations of Dictionaries/Lists/StringBuilder/HashSet Types</value>
  </data>
  <data name="9095c47b63d2447aac647d6740226546_Description" xml:space="preserve">
    <value>Too much CPU is spent in allocations of types like List, StringBuilder, Dictionary, HashSet etc., which can be reused.</value>
  </data>
  <data name="9095c47b63d2447aac647d6740226546_Recommendation" xml:space="preserve">
    <value>This can be fixed by reusing instances of these types instead of allocating a new one every time.</value>
  </data>
  <data name="9095c47b63d2447aac647d6740226546_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="3095f90e3f924868a30ed645a4be2395_Title" xml:space="preserve">
    <value>Inefficient String Concatenation</value>
  </data>
  <data name="3095f90e3f924868a30ed645a4be2395_Description" xml:space="preserve">
    <value>Excessive string concatenation is causing lots of allocations and CPU consumption.</value>
  </data>
  <data name="3095f90e3f924868a30ed645a4be2395_Recommendation" xml:space="preserve">
    <value>Consider using cheaper alternatives such as `String.Join` or a `StringBuilder` instead.</value>
  </data>
  <data name="3095f90e3f924868a30ed645a4be2395_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="4a8a2a456f67474eb30779d8b507d466_Title" xml:space="preserve">
    <value>Heap Allocations Due to Tuples</value>
  </data>
  <data name="4a8a2a456f67474eb30779d8b507d466_Description" xml:space="preserve">
    <value>Tuples in C# are classes so they need to be allocated on the Heap. As a result, `Dictionary&lt;K, V&gt;.FindEntry()` seems to be causing allocations.</value>
  </data>
  <data name="4a8a2a456f67474eb30779d8b507d466_Recommendation" xml:space="preserve">
    <value>Consider replacing `Tuple` with `ValueTuple`, which are structs and are no allocated on the Heap.</value>
  </data>
  <data name="4a8a2a456f67474eb30779d8b507d466_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="d77d16b35af14b518d99bc75c0b088a8_Title" xml:space="preserve">
    <value>High CPU Costs Due to Expensive Methods</value>
  </data>
  <data name="d77d16b35af14b518d99bc75c0b088a8_Description" xml:space="preserve">
    <value>Expensive methods such as `ConcurrentDictionary&lt;T1, T2&gt;.GetKeys()`, `Process.ProcessName`, `DateTime.Now`, `System.Type.GetType()`, `GetCustomAttributes()`, etc. are consuming a lot of CPU.</value>
  </data>
  <data name="d77d16b35af14b518d99bc75c0b088a8_Recommendation" xml:space="preserve">
    <value>Consider caching the results of these methods.</value>
  </data>
  <data name="d77d16b35af14b518d99bc75c0b088a8_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="63a56899bfd24cf5aae4a781df3799e8_Title" xml:space="preserve">
    <value>`CopyTo` Taking Too Much CPU</value>
  </data>
  <data name="63a56899bfd24cf5aae4a781df3799e8_Description" xml:space="preserve">
    <value>`CopyTo` is taking a lot of CPU. This may be because of the buffer size being too small.</value>
  </data>
  <data name="63a56899bfd24cf5aae4a781df3799e8_Recommendation" xml:space="preserve">
    <value>Consider increasing the buffer size supplied to the `CopyTo` method.</value>
  </data>
  <data name="63a56899bfd24cf5aae4a781df3799e8_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="f7d870e1c92949faa59fbf8e034edeb1_Title" xml:space="preserve">
    <value>`Activator.CreateInstance` Taking Too Much CPU</value>
  </data>
  <data name="f7d870e1c92949faa59fbf8e034edeb1_Description" xml:space="preserve">
    <value>`Activator.CreateInstance` takes up a lot of CPU because it is implemented using Reflection.</value>
  </data>
  <data name="f7d870e1c92949faa59fbf8e034edeb1_Recommendation" xml:space="preserve">
    <value>Consider using alternatives such as passing in an allocation delegate, compiled lambdas or emitting IL.</value>
  </data>
  <data name="f7d870e1c92949faa59fbf8e034edeb1_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="82a95bad3d444d948075449394c1859d_Title" xml:space="preserve">
    <value>`Regex.IsMatch` Taking Too Much CPU</value>
  </data>
  <data name="82a95bad3d444d948075449394c1859d_Description" xml:space="preserve">
    <value>`Regex.IsMatch` is taking up a lot of CPU.</value>
  </data>
  <data name="82a95bad3d444d948075449394c1859d_Recommendation" xml:space="preserve">
    <value>Consider using a compiled regex using `RegexOptions.Compiled` or compiling to assembly using `RegexOptions.CompileToAssembly`.</value>
  </data>
  <data name="82a95bad3d444d948075449394c1859d_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="3252749ac8cf40559a66c0ba16f7703c_Title" xml:space="preserve">
    <value>Excessive Allocations Due to `System.Stream.ReadByte()`/`System.Stream.WriteByte()`</value>
  </data>
  <data name="3252749ac8cf40559a66c0ba16f7703c_Description" xml:space="preserve">
    <value>When deriving from `System.Stream`, the default implementations of `ReadByte`/`WriteByte` would be used unless overridden. These methods allocate a single byte array upon each run, which can lead to a lot of Heap allocations.</value>
  </data>
  <data name="3252749ac8cf40559a66c0ba16f7703c_Recommendation" xml:space="preserve">
    <value>Make sure you are not missing overrides of `ReadByte`/`WriteByte` when deriving `System.Stream` and using a cached buffer.</value>
  </data>
  <data name="3252749ac8cf40559a66c0ba16f7703c_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="3c56330dca864ea6a7a4c97c9e08418d_Title" xml:space="preserve">
    <value>`IEnumerable&lt;T&gt;.Count()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="3c56330dca864ea6a7a4c97c9e08418d_Description" xml:space="preserve">
    <value>Calling `IEnumerable&lt;T&gt;.Count()`, causes the entire enumerable to be enumerated. This can lead to multiple enumeration if `IEnumerable&lt;T&gt;.Count()` is called on the same enumerable from multiple locations.</value>
  </data>
  <data name="3c56330dca864ea6a7a4c97c9e08418d_Recommendation" xml:space="preserve">
    <value>Make sure the same enumerable is not being enumerated on multiple times. If more than one calls are found and the enumerable doesn't change between successive calls to `Count()`, consider caching and re-using the results.
Other options are to use `List&lt;T&gt;` to get access to `Count` property, or check if the enumerable is an `ICollection&lt;T&gt;` underneath to avoid having to call `ToList()`.
Use `IEnumerable&lt;T&gt;.Any()` if count is only used to check whether the enumerable is non-empty.</value>
  </data>
  <data name="3c56330dca864ea6a7a4c97c9e08418d_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="a41d3cf029c241bca01a6e38d77db0ad_Title" xml:space="preserve">
    <value>`IEnumerable&lt;T&gt;.ElementAt()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="a41d3cf029c241bca01a6e38d77db0ad_Description" xml:space="preserve">
    <value>`ElementAt` iterates over the entire enumerable to find the element at a specific index.</value>
  </data>
  <data name="a41d3cf029c241bca01a6e38d77db0ad_Recommendation" xml:space="preserve">
    <value>Consider using `List&lt;T&gt;` as it has constant access to elements by index.</value>
  </data>
  <data name="a41d3cf029c241bca01a6e38d77db0ad_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="991d40cb6bf746ba97d43b460273a659_Title" xml:space="preserve">
    <value>`List&lt;T&gt;.Contains()` Taking Up Too Much CPU</value>
  </data>
  <data name="991d40cb6bf746ba97d43b460273a659_Description" xml:space="preserve">
    <value>`List&lt;T&gt;.Contains()` needs to iterate over the `List` to check if an element exists, which tends to be O(N) in the worst case.</value>
  </data>
  <data name="991d40cb6bf746ba97d43b460273a659_Recommendation" xml:space="preserve">
    <value>Consider using a `HashSet&lt;T&gt;` instead of a `List&lt;T&gt;` or maintaining one in addition to the `List`.</value>
  </data>
  <data name="991d40cb6bf746ba97d43b460273a659_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="9e7e6b7dc3a74b0781efed305b58d22f_Title" xml:space="preserve">
    <value>`ContainsKey` Taking Too Much CPU</value>
  </data>
  <data name="9e7e6b7dc3a74b0781efed305b58d22f_Description" xml:space="preserve">
    <value>Using `Dictionary&lt;K, V&gt;.ContainsKey()` along with a `Dictionary` lookup can lead to double dictionary lookup anti-pattern.</value>
  </data>
  <data name="9e7e6b7dc3a74b0781efed305b58d22f_Recommendation" xml:space="preserve">
    <value>Consider replacing `Dictionary&lt;K, V&gt;.ContainsKey()` and lookup with `Dictionary&lt;K, V&gt;.TryGetValue()`, which is more optimal as it avoids the double cost of checking if a key exists in the `Dictionary` and then accessing the corresponding value, and instead gets both results in a single call.</value>
  </data>
  <data name="9e7e6b7dc3a74b0781efed305b58d22f_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="210fc8b5d6544813b44f296c4f6a2df7_Title" xml:space="preserve">
    <value>`ConcurrentDictionary&lt;K, V&gt;.Count` Taking Too Much CPU</value>
  </data>
  <data name="210fc8b5d6544813b44f296c4f6a2df7_Description" xml:space="preserve">
    <value>`ConcurrentDictionary&lt;K, V&gt;.Count` takes a lock and calling it too frequently can cause CPU bottlenecks.</value>
  </data>
  <data name="210fc8b5d6544813b44f296c4f6a2df7_Recommendation" xml:space="preserve">
    <value>Consider keeping a cached local count and updating it using `Interlocked.Increment`/`Decrement`.</value>
  </data>
  <data name="210fc8b5d6544813b44f296c4f6a2df7_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="2e20ddeaae18465cb74e3df385578ad6_Title" xml:space="preserve">
    <value>`IEnumerable&lt;T&gt;.OrderBy().FirstOrDefault()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="2e20ddeaae18465cb74e3df385578ad6_Description" xml:space="preserve">
    <value>LINQ query `IEnumerable&lt;T&gt;.OrderBy().FirstOrDefault()` sorts the entire enumerable only to get the smallest/largest element, which can be very slow because of having O(N*log(N)) complexity.</value>
  </data>
  <data name="2e20ddeaae18465cb74e3df385578ad6_Recommendation" xml:space="preserve">
    <value>This can be done in O(N) by simply iterating over the enumerable and getting the smallest/largest element or using `MinBy`/`MaxBy` on the `IEnumerable&lt;T&gt;`.</value>
  </data>
  <data name="2e20ddeaae18465cb74e3df385578ad6_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="23a5db7d682e42f7928dabb061a755cc_Title" xml:space="preserve">
    <value>`Array.Reverse()` Taking Too Much CPU/Memory Due to Boxing</value>
  </data>
  <data name="23a5db7d682e42f7928dabb061a755cc_Description" xml:space="preserve">
    <value>`Array.Reverse` is a non-generic method and is implemented using boxing.</value>
  </data>
  <data name="23a5db7d682e42f7928dabb061a755cc_Recommendation" xml:space="preserve">
    <value>Consider implementing your own reverse function.</value>
  </data>
  <data name="23a5db7d682e42f7928dabb061a755cc_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="3f51a46a39c3462eab77f3f15ca60f1f_Title" xml:space="preserve">
    <value>Lock Contention in `TraceSource.TraceData()`</value>
  </data>
  <data name="3f51a46a39c3462eab77f3f15ca60f1f_Description" xml:space="preserve">
    <value>`TraceSource.TraceData()` is taking up a lot of CPU due to lock contention.</value>
  </data>
  <data name="3f51a46a39c3462eab77f3f15ca60f1f_Recommendation" xml:space="preserve">
    <value>Avoid using `TraceSource.TraceData()`, or make sure all listeners are thread-safe to turn off locking.</value>
  </data>
  <data name="3f51a46a39c3462eab77f3f15ca60f1f_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="d19b35dd29e64a1a9576864123829a05_Title" xml:space="preserve">
    <value>Unnecessary String Allocations and CPU Usage Due to `String.Split()`</value>
  </data>
  <data name="d19b35dd29e64a1a9576864123829a05_Description" xml:space="preserve">
    <value>`String.Split()` can lead to unnecessary string allocations and CPU usage.</value>
  </data>
  <data name="d19b35dd29e64a1a9576864123829a05_Recommendation" xml:space="preserve">
    <value>Consider using cheaper alternatives.</value>
  </data>
  <data name="d19b35dd29e64a1a9576864123829a05_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="7538665d770d40fb851e2c133f8ef4ed_Title" xml:space="preserve">
    <value>Expensive `IEnumerable&lt;T&gt;.ToList()` in Getter</value>
  </data>
  <data name="7538665d770d40fb851e2c133f8ef4ed_Description" xml:space="preserve">
    <value>An expensive call to `IEnumerable&lt;T&gt;.ToList()` is being made from a getter.</value>
  </data>
  <data name="7538665d770d40fb851e2c133f8ef4ed_Recommendation" xml:space="preserve">
    <value>Consider memoizing the results of `ToList` to make the getter as cheap as possible.</value>
  </data>
  <data name="7538665d770d40fb851e2c133f8ef4ed_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="2efbfd50159a42f788b94e5ad37de914_Title" xml:space="preserve">
    <value>`IEnumerable&lt;T&gt;.ToList()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="2efbfd50159a42f788b94e5ad37de914_Description" xml:space="preserve">
    <value>A lot of CPU or Memory is being spent in `IEnumerable&lt;T&gt;.ToList()`.</value>
  </data>
  <data name="2efbfd50159a42f788b94e5ad37de914_Recommendation" xml:space="preserve">
    <value>Consider using `List&lt;T&gt;` from the start to avoid expensive calls to ToList(). Also, verify that `IEnumerable&lt;T&gt;.ToList()` isn't being called for a single enumeration, which can be accomplished simply by enumerating over the `IEnumerable&lt;T&gt;`.</value>
  </data>
  <data name="2efbfd50159a42f788b94e5ad37de914_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="889dd9ee4eb043d09817e10991ab4665_Title" xml:space="preserve">
    <value>Unnecessary Allocations and CPU Cost Due to Boxing</value>
  </data>
  <data name="889dd9ee4eb043d09817e10991ab4665_Description" xml:space="preserve">
    <value>Boxing is used to store value types in the garbage-collected heap. Boxing is an implicit conversion of a value type to the type object or to any interface type implemented by this value type. Boxing a value type allocates an object instance on the heap and copies the value into the new object.
Boxing and unboxing are computationally expensive processes. When a value type is boxed, a new object must be allocated and constructed. To a lesser degree, the cast required for unboxing is also expensive computationally.</value>
  </data>
  <data name="889dd9ee4eb043d09817e10991ab4665_Recommendation" xml:space="preserve">
    <value>It is best to avoid using value types in situations where they must be boxed a high number of times, for example in non-generic collections classes such as `Collections.ArrayList`. You can avoid boxing of value types by using generic collections such as `List&lt;T&gt;`.</value>
  </data>
  <data name="889dd9ee4eb043d09817e10991ab4665_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="dfebc4ff775b406ea3655e225d6a52ee_Title" xml:space="preserve">
    <value>Too Much Exception Handling</value>
  </data>
  <data name="dfebc4ff775b406ea3655e225d6a52ee_Description" xml:space="preserve">
    <value>CPU Bottlenecks are showing up due to excessive exception handling.</value>
  </data>
  <data name="dfebc4ff775b406ea3655e225d6a52ee_Recommendation" xml:space="preserve">
    <value>Investigate why so many exceptions are being thrown, as this may be due to an underlying bug.</value>
  </data>
  <data name="dfebc4ff775b406ea3655e225d6a52ee_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="cfe41042b35546b6893332e6d378dd00_Title" xml:space="preserve">
    <value>Garbage Collection Showing Up in CPU Trace</value>
  </data>
  <data name="cfe41042b35546b6893332e6d378dd00_Description" xml:space="preserve">
    <value>Induced Garbage Collection (GC) is showing up as a bottleneck in CPU trace.</value>
  </data>
  <data name="cfe41042b35546b6893332e6d378dd00_Recommendation" xml:space="preserve">
    <value>Look at the allocation data and your code to make sure there are no unnecessary allocations.</value>
  </data>
  <data name="cfe41042b35546b6893332e6d378dd00_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="cf44c71664554dc09fa4343a212444e1_Title" xml:space="preserve">
    <value>`X509Certificate.X509Chain.Build` Taking Too Much CPU</value>
  </data>
  <data name="cf44c71664554dc09fa4343a212444e1_Description" xml:space="preserve">
    <value>`X509Chain.Build` is called on each request, instead of being cached.</value>
  </data>
  <data name="cf44c71664554dc09fa4343a212444e1_Recommendation" xml:space="preserve">
    <value>Consider using a newer version of .NET (&gt;5), which caches the chain result so that it is not built on each request. Also, if you are using containers, consider switching to Windows containers as they have faster X509 chain building.</value>
  </data>
  <data name="cf44c71664554dc09fa4343a212444e1_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="4810b7addcb2483ab6af6bf7562b1fe6_Title" xml:space="preserve">
    <value>Lock Contention Appearing in CPU Trace</value>
  </data>
  <data name="4810b7addcb2483ab6af6bf7562b1fe6_Description" xml:space="preserve">
    <value>Lock contention occurs when a thread waits for a lock while another thread possesses that lock. Contentious locks can be bad for your application's throughput and lead to scalability issues.</value>
  </data>
  <data name="4810b7addcb2483ab6af6bf7562b1fe6_Recommendation" xml:space="preserve">
    <value>Consider options like reducing lock granularity, using a lock-free library or re-writing the code such that it doesn't require a lock.</value>
  </data>
  <data name="4810b7addcb2483ab6af6bf7562b1fe6_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="cfa35fd61c4a411a9e56d4b6989e1b73_Title" xml:space="preserve">
    <value>Active Directory Taking Too Much CPU/Memory</value>
  </data>
  <data name="cfa35fd61c4a411a9e56d4b6989e1b73_Description" xml:space="preserve">
    <value>Active Directory is causing CPU bottlenecks and allocations.</value>
  </data>
  <data name="cfa35fd61c4a411a9e56d4b6989e1b73_Recommendation" xml:space="preserve">
    <value>Consider switching from Active Directory Authentication Library (ADAL) to Microsoft Authentication Library (MSAL).</value>
  </data>
  <data name="cfa35fd61c4a411a9e56d4b6989e1b73_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="bb77a27d7115415d9205d1efde790f78_Title" xml:space="preserve">
    <value>String.ToLower() Taking Too Much CPU/Memory</value>
  </data>
  <data name="bb77a27d7115415d9205d1efde790f78_Description" xml:space="preserve">
    <value>ToLower is taking a lot of CPU/Memory. This may be because of repeat calls to ToLower on the same set of strings.</value>
  </data>
  <data name="bb77a27d7115415d9205d1efde790f78_Recommendation" xml:space="preserve">
    <value>Consider using CaseInsensitive comparisons or caching the results of ToLower.</value>
  </data>
  <data name="bb77a27d7115415d9205d1efde790f78_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="cdf08e8f36e5402491107b887ba6f112_Title" xml:space="preserve">
    <value>Inefficient `String.SubString()`</value>
  </data>
  <data name="cdf08e8f36e5402491107b887ba6f112_Description" xml:space="preserve">
    <value>Excessive `String.SubString()` is causing lots of allocations and CPU consumption.</value>
  </data>
  <data name="cdf08e8f36e5402491107b887ba6f112_Recommendation" xml:space="preserve">
    <value>Consider using cheaper alternatives such as `String.AsSpan()`.</value>
  </data>
  <data name="cdf08e8f36e5402491107b887ba6f112_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="86763918439147e7ab4de83b1b06066a_Title" xml:space="preserve">
    <value>Calls To Static Regex Functions Causing Contention</value>
  </data>
  <data name="86763918439147e7ab4de83b1b06066a_Description" xml:space="preserve">
    <value>Static Regex calls are causing contention in the Regex cache.</value>
  </data>
  <data name="86763918439147e7ab4de83b1b06066a_Recommendation" xml:space="preserve">
    <value>Consider creating an instance of the `Regex` and call the member method `IsMatch`\`Match`\`Split` instead of calling the static variants.</value>
  </data>
  <data name="86763918439147e7ab4de83b1b06066a_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="7c07a45a9234419d95d16b3b77d38219_Title" xml:space="preserve">
    <value>Excessive Calls to `Enum.ToString()`</value>
  </data>
  <data name="7c07a45a9234419d95d16b3b77d38219_Description" xml:space="preserve">
    <value>Excessive `Enum.ToString()` causing lots of allocations.</value>
  </data>
  <data name="7c07a45a9234419d95d16b3b77d38219_Recommendation" xml:space="preserve">
    <value>Consider caching `Enum.ToString()` results in a dictionary.</value>
  </data>
  <data name="7c07a45a9234419d95d16b3b77d38219_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="c96149cd8d3c4f09985476ed3f5405ae_Title" xml:space="preserve">
    <value>High CPU/Memory Costs Due to Logging</value>
  </data>
  <data name="c96149cd8d3c4f09985476ed3f5405ae_Description" xml:space="preserve">
    <value>Too much CPU/Memory is being spent in logging.</value>
  </data>
  <data name="c96149cd8d3c4f09985476ed3f5405ae_Recommendation" xml:space="preserve">
    <value>Check logging levels and reduce the volume of logs in production. Consider tweaking level for each category. Also consider high performance logging (Reference: https://aka.ms/AAfkq94).</value>
  </data>
  <data name="c96149cd8d3c4f09985476ed3f5405ae_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="51eb34e86c6b4442952fc53e4a97f67f_Title" xml:space="preserve">
    <value>Too Much CPU/Memory Taken by LINQ Query Chaining `IEnumerable&lt;T&gt;.Where()` and `IEnumerable&lt;T&gt;.Count()`</value>
  </data>
  <data name="51eb34e86c6b4442952fc53e4a97f67f_Description" xml:space="preserve">
    <value>Nested `Where` calls would lead to multiple passes over the enumerable leading to unnecessary CPU usage as well as iterator allocations.</value>
  </data>
  <data name="51eb34e86c6b4442952fc53e4a97f67f_Recommendation" xml:space="preserve">
    <value>Consider condensing the chain of `IEnumerable&lt;T&gt;.Where(&lt;lambda function&gt;).Count()` to simply a `IEnumerable&lt;T&gt;.Count(&lt;lambda function&gt;)`.</value>
  </data>
  <data name="51eb34e86c6b4442952fc53e4a97f67f_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="867032d67d2d4edd9f6cfa132ca45fdd_Title" xml:space="preserve">
    <value>Excessive Allocations of `KeyVaultClient` Type</value>
  </data>
  <data name="867032d67d2d4edd9f6cfa132ca45fdd_Description" xml:space="preserve">
    <value>Too many allocations of type `KeyVaultClient`, which need not be re-allocated if an instance pointing to the same Key Vault already exists.</value>
  </data>
  <data name="867032d67d2d4edd9f6cfa132ca45fdd_Recommendation" xml:space="preserve">
    <value>Consider reusing `KeyVaultClient` instances.</value>
  </data>
  <data name="867032d67d2d4edd9f6cfa132ca45fdd_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="93f5643f7bb645f0947e73f48e27c8da_Title" xml:space="preserve">
    <value>`IEnumerable&lt;T&gt;.Any()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="93f5643f7bb645f0947e73f48e27c8da_Description" xml:space="preserve">
    <value>A lot of CPU or Memory is being consumed by `IEnumerable&lt;T&gt;.Any()` calls.</value>
  </data>
  <data name="93f5643f7bb645f0947e73f48e27c8da_Recommendation" xml:space="preserve">
    <value>Consider unrolling the LINQ expression to use an explicit for-loop.
In case of nested LINQ expressions, make sure that same computations are not being repeated unnecessarily.
If possible, hoist them to the outermost loop where they can be computed.</value>
  </data>
  <data name="93f5643f7bb645f0947e73f48e27c8da_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="233a5e731b974b8fbdce7ff32a19ae0a_Title" xml:space="preserve">
    <value>`Dictionary&lt;K, V&gt;.FindEntry()` Taking Too Much CPU</value>
  </data>
  <data name="233a5e731b974b8fbdce7ff32a19ae0a_Description" xml:space="preserve">
    <value>A lot of exclusive CPU time is being spent in `Dictionary&lt;K, V&gt;.FindEntry()` calls.</value>
  </data>
  <data name="233a5e731b974b8fbdce7ff32a19ae0a_Recommendation" xml:space="preserve">
    <value>This often happens when a Dictionary gets corrupted due to unguarded concurrent writes.
If this is occurring, consider using a ConcurrentDictionary instead or appropriate lock protection.</value>
  </data>
  <data name="233a5e731b974b8fbdce7ff32a19ae0a_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="9887cafc662a45358507cbc350e8b63b_Title" xml:space="preserve">
    <value>`Newtonsoft.Json.JsonConvert.SerializeObject()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="9887cafc662a45358507cbc350e8b63b_Description" xml:space="preserve">
    <value>A lot of CPU and memory are being spent on calls to `Newtonsoft.Json.JsonConvert.SerializeObject()`.</value>
  </data>
  <data name="9887cafc662a45358507cbc350e8b63b_Recommendation" xml:space="preserve">
    <value>Make sure you're not recreating a `ContractResolver` every time you use `JsonSerializer`. Instead, you should create the contract resolver once and reuse it. Please note that if you are not using an explicit contract resolver, then a shared internal instance is automatically used when serializing and deserializing.

If you have .NET 5 SDK or above, consider switching to `System.Text.Json` to use source generation, regardless of the .NET version you target. Source generation allows for the inspection of serializable types to be done at compile time instead of needing to use reflection at runtime and is, therefore, able to provide much better performance.

Please note that when using `System.Text.Json`, if you need to use `JsonSerializerOptions` repeatedly with the same options, consider reusing the same `JsonSerializerOptions` instance for each call to Serialize/Deserialize. Since the instance is thread-safe and immutable after the first serialization or deserialization, it's safe to use the same instance.</value>
  </data>
  <data name="9887cafc662a45358507cbc350e8b63b_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="cbf057a5f58e4b9dbdb1a15941bde5bc_Title" xml:space="preserve">
    <value>`Newtonsoft.Json.JsonConvert.DeserializeObject()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="cbf057a5f58e4b9dbdb1a15941bde5bc_Description" xml:space="preserve">
    <value>A lot of CPU and memory are being spent on calls to `Newtonsoft.Json.JsonConvert.DeserializeObject()`.</value>
  </data>
  <data name="cbf057a5f58e4b9dbdb1a15941bde5bc_Recommendation" xml:space="preserve">
    <value>Make sure you're not recreating a `ContractResolver` every time you use `JsonSerializer`. Instead, you should create the contract resolver once and reuse it. Please note that if you are not using an explicit contract resolver, then a shared internal instance is automatically used when serializing and deserializing.

If you have .NET 5 SDK or above, consider switching to `System.Text.Json` to use source generation, regardless of the .NET version you target. Source generation allows for the inspection of serializable types to be done at compile time instead of needing to use reflection at runtime and is, therefore, able to provide much better performance.

Please note that when using `System.Text.Json`, if you need to use `JsonSerializerOptions` repeatedly with the same options, consider reusing the same `JsonSerializerOptions` instance for each call to Serialize/Deserialize. Since the instance is thread-safe and immutable after the first serialization or deserialization, it's safe to use the same instance.</value>
  </data>
  <data name="cbf057a5f58e4b9dbdb1a15941bde5bc_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="4b8e9c5d34b7480b83934cb74a0afcf7_Title" xml:space="preserve">
    <value>`IEnumerable&lt;T&gt;.Single()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="4b8e9c5d34b7480b83934cb74a0afcf7_Description" xml:space="preserve">
    <value>A lot of CPU or Memory is being consumed by `IEnumerable&lt;T&gt;.Single()` calls.</value>
  </data>
  <data name="4b8e9c5d34b7480b83934cb74a0afcf7_Recommendation" xml:space="preserve">
    <value>Consider unrolling the LINQ expression to use an explicit for-loop.
In case of nested LINQ expressions, make sure that same computations are not being repeated unnecessarily.
If possible, hoist them to the outermost loop where they can be computed.</value>
  </data>
  <data name="4b8e9c5d34b7480b83934cb74a0afcf7_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="67b8a6d11a2c4c1abf9c9f5778f69dee_Title" xml:space="preserve">
    <value>`IEnumerable&lt;T&gt;.FirstOrDefault()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="67b8a6d11a2c4c1abf9c9f5778f69dee_Description" xml:space="preserve">
    <value>A lot of CPU or Memory is being consumed by `IEnumerable&lt;T&gt;.FirstOrDefault()` calls.</value>
  </data>
  <data name="67b8a6d11a2c4c1abf9c9f5778f69dee_Recommendation" xml:space="preserve">
    <value>Consider unrolling the LINQ expression to use an explicit for-loop.
In case of nested LINQ expressions, make sure that same computations are not being repeated unnecessarily.
If possible, hoist them to the outermost loop where they can be computed.</value>
  </data>
  <data name="67b8a6d11a2c4c1abf9c9f5778f69dee_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="5586dc2a849340068f5c5dbb00c44229_Title" xml:space="preserve">
    <value>`IEnumerable&lt;T&gt;.Aggregate()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="5586dc2a849340068f5c5dbb00c44229_Description" xml:space="preserve">
    <value>A lot of CPU or Memory is being consumed by `IEnumerable&lt;T&gt;.Aggregate()` calls.</value>
  </data>
  <data name="5586dc2a849340068f5c5dbb00c44229_Recommendation" xml:space="preserve">
    <value>Consider unrolling the LINQ expression to use an explicit for-loop.
In case of nested LINQ expressions, make sure that same computations are not being repeated unnecessarily.
If possible, hoist them to the outermost loop where they can be computed.</value>
  </data>
  <data name="5586dc2a849340068f5c5dbb00c44229_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="e892ab768c7a4203af18a7823b31386a_Title" xml:space="preserve">
    <value>`Enumerable&lt;T&gt;.ToArray()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="e892ab768c7a4203af18a7823b31386a_Description" xml:space="preserve">
    <value>A lot of CPU or Memory is being spent in `Enumerable&lt;T&gt;.ToArray()`.</value>
  </data>
  <data name="e892ab768c7a4203af18a7823b31386a_Recommendation" xml:space="preserve">
    <value>Verify that `Enumerable&lt;T&gt;.ToArray()` isn't being called for a single enumeration, which can be accomplished simply by enumerating over the `Enumerable&lt;T&gt;`.</value>
  </data>
  <data name="e892ab768c7a4203af18a7823b31386a_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="1353f344ea4344f399cf6ac7e7f7237a_Title" xml:space="preserve">
    <value>`Enumerable&lt;T&gt;.ToDictionary()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="1353f344ea4344f399cf6ac7e7f7237a_Description" xml:space="preserve">
    <value>A lot of CPU or Memory is being spent in `Enumerable&lt;T&gt;.ToDictionary()`.</value>
  </data>
  <data name="1353f344ea4344f399cf6ac7e7f7237a_Recommendation" xml:space="preserve">
    <value>Verify that `Enumerable&lt;T&gt;.ToDictionary()` isn't being called for a few look-ups in the resulting `Dictionary&lt;K, V&gt;`. This can instead be accomplished simply by enumerating over the `Enumerable&lt;T&gt;`.</value>
  </data>
  <data name="1353f344ea4344f399cf6ac7e7f7237a_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="b9f34b5c3c9243abaa57e02c2bcf9ee6_Title" xml:space="preserve">
    <value>`Queryable&lt;T&gt;.FirstOrDefault()` Taking Too Much CPU/Memory</value>
  </data>
  <data name="b9f34b5c3c9243abaa57e02c2bcf9ee6_Description" xml:space="preserve">
    <value>A lot of CPU or Memory is being spent in `Queryable&lt;T&gt;.FirstOrDefault()`.</value>
  </data>
  <data name="b9f34b5c3c9243abaa57e02c2bcf9ee6_Recommendation" xml:space="preserve">
    <value>Examine the query and simplify the expression if possible.</value>
  </data>
  <data name="b9f34b5c3c9243abaa57e02c2bcf9ee6_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="0be5bb8fd2a1403d94e73b0fa4e62ad6_Title" xml:space="preserve">
    <value>`StreamReader.ReadToEnd()` Taking Too Much Memory</value>
  </data>
  <data name="0be5bb8fd2a1403d94e73b0fa4e62ad6_Description" xml:space="preserve">
    <value>A lot of Memory is being consumed by `StreamReader.ReadToEnd()`.</value>
  </data>
  <data name="0be5bb8fd2a1403d94e73b0fa4e62ad6_Recommendation" xml:space="preserve">
    <value>If the underlying stream is expected to be in JSON format, consider using a JSON parser directly over the stream rather than reading to a string and then parsing the resulting string.</value>
  </data>
  <data name="0be5bb8fd2a1403d94e73b0fa4e62ad6_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="1eabc3f5c4704829902f0be5f8a38b66_Title" xml:space="preserve">
    <value>`CompareInfo.IsPrefix()` Taking Too Much CPU</value>
  </data>
  <data name="1eabc3f5c4704829902f0be5f8a38b66_Description" xml:space="preserve">
    <value>A lot of CPU is being spent doing culture specific comparisons within calls to `CompareInfo.IsPrefix()`.</value>
  </data>
  <data name="1eabc3f5c4704829902f0be5f8a38b66_Recommendation" xml:space="preserve">
    <value>Consider specifying a `StringComparison.Ordinal` comparison with `String.StartsWith`/`String.EndsWith` to avoid doing culture specific string comparisons, which tend to be more expensive.</value>
  </data>
  <data name="1eabc3f5c4704829902f0be5f8a38b66_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="220f26e53670439fa19763897251b4b6_Title" xml:space="preserve">
    <value>`String.IndexOf()` Taking Too Much CPU</value>
  </data>
  <data name="220f26e53670439fa19763897251b4b6_Description" xml:space="preserve">
    <value>A lot of CPU is being spent doing culture specific comparisons within calls to `String.IndexOf()`.</value>
  </data>
  <data name="220f26e53670439fa19763897251b4b6_Recommendation" xml:space="preserve">
    <value>Consider specifying a `StringComparison.Ordinal` comparison with `String.IndexOf` to avoid doing culture specific string comparisons, which tend to be more expensive.</value>
  </data>
  <data name="220f26e53670439fa19763897251b4b6_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="ef41de0e0b0045ff8f9a1c7530c06d91_Title" xml:space="preserve">
    <value>`Dictionary&lt;K, V&gt;.Insert()` Taking Too Much CPU Due To `ObjectEqualityComparer`</value>
  </data>
  <data name="ef41de0e0b0045ff8f9a1c7530c06d91_Description" xml:space="preserve">
    <value>A lot of CPU is being spent on calls to `Dictionary&lt;K, V&gt;.Insert()`.</value>
  </data>
  <data name="ef41de0e0b0045ff8f9a1c7530c06d91_Recommendation" xml:space="preserve">
    <value>Avoid using the default object comparer. Consider writing a custom comparer for the Dictionary Key type and specifying it in the Dictionary's constructor. Alternatively, implement `IEquatable&lt;TKey&gt;` on the Key type. Either of these will lead to faster comparisons than the default object comparer.</value>
  </data>
  <data name="ef41de0e0b0045ff8f9a1c7530c06d91_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="70472c330a674a1aa2d58284c449a3b7_Title" xml:space="preserve">
    <value>`Dictionary&lt;K, V&gt;.Insert()` Taking Too Much CPU</value>
  </data>
  <data name="70472c330a674a1aa2d58284c449a3b7_Description" xml:space="preserve">
    <value>A lot of CPU is being spent on calls to `Dictionary&lt;K, V&gt;.Insert()`.</value>
  </data>
  <data name="70472c330a674a1aa2d58284c449a3b7_Recommendation" xml:space="preserve">
    <value>Make sure Dictionary entries are actually being re-used in look-ups.</value>
  </data>
  <data name="70472c330a674a1aa2d58284c449a3b7_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
  <data name="5e8edd3927f049beb99c572b9a4d536b_Title" xml:space="preserve">
    <value>Excessive Allocations of `System.Text.RegularExpressions.Regex`</value>
  </data>
  <data name="5e8edd3927f049beb99c572b9a4d536b_Description" xml:space="preserve">
    <value>A lot of memory is spent in allocations of type `System.Text.RegularExpressions.Regex`.</value>
  </data>
  <data name="5e8edd3927f049beb99c572b9a4d536b_Recommendation" xml:space="preserve">
    <value>Avoid creating Regex instances more than once with the same regular expression. If the regular expression is the same each time, then cache a single Regex instance in a static field.</value>
  </data>
  <data name="5e8edd3927f049beb99c572b9a4d536b_Rationale" xml:space="preserve">
    <value>{value}% of your {issueCategory} was spent in `{function}`, We expected this value to be {relation} {criteria}%.</value>
  </data>
</root>